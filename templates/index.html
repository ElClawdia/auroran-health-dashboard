<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auroran Health Command Center</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="shortcut icon" href="/favicon.svg">
    <link rel="apple-touch-icon" href="/favicon.svg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #0d1117;
            --card-bg: #161b22;
            --border: #30363d;
            --primary: #58a6ff;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --text: #c9d1d9;
            --text-dim: #8b949e;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            touch-action: pan-y;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            touch-action: pan-y;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        h1 {
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        h1 .emoji {
            font-size: 2rem;
        }

        
        .subtitle {
            color: var(--text-dim);
            font-size: 0.9rem;
            margin-top: 4px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        
        .account-link {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-dim);
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background 0.2s, color 0.2s;
        }
        
        .account-link:hover {
            background: var(--card-bg);
            color: var(--primary);
        }
        
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }
        
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }
        
        .card-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
        }
        
        .card-action-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: background 0.2s, color 0.2s;
            opacity: 0.5;
        }

        .card:hover .card-action-btn {
            opacity: 1;
        }
        
        .card-action-btn:hover {
            background: var(--border);
            color: var(--primary);
        }
        
        .card-action-btn.active {
            opacity: 1;
            color: var(--primary);
        }
        
        .card-action-btn.refresh-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            top: auto;
        }
        
        .card-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .card-value {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .card-value.editing {
            display: none;
        }
        
        .card-input {
            display: none;
            width: 100%;
            font-size: 1.8rem;
            font-weight: 600;
            background: var(--bg);
            border: 2px solid var(--primary);
            border-radius: 8px;
            color: var(--text);
            padding: 4px 8px;
            margin-bottom: 4px;
        }
        
        .card-input.editing {
            display: block;
        }
        
        .card-date-picker {
            display: none;
            font-size: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            padding: 4px 8px;
            margin-bottom: 6px;
            cursor: pointer;
        }
        
        .card-date-picker.editing {
            display: block;
        }
        
        /* Date Navigation Bar */
        .date-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 20px;
            padding: 12px 20px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
        }
        
        .date-nav-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .date-nav-btn:hover:not(:disabled) {
            background: var(--border);
            border-color: var(--primary);
        }
        
        .date-nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .date-nav-current {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text);
            min-width: 180px;
            text-align: center;
            cursor: pointer;
            padding: 8px 16px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .date-nav-current:hover {
            background: var(--bg);
        }
        
        .date-nav-current.is-today {
            color: var(--primary);
        }
        
        .date-nav-input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .card.manual-value .card-value::after {
            content: ' ‚úé';
            font-size: 0.6em;
            color: var(--text-dim);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .card.manual-value:hover .card-value::after {
            opacity: 1;
        }
        
        .card.hidden-card {
            opacity: 0.4;
        }
        
        .card.hidden-card .card-value {
            filter: blur(8px);
        }
        
        .card-action-btn.hide-btn {
            position: absolute;
            bottom: 8px;
            left: 8px;
            top: auto;
            right: auto;
        }
        
        .card.clickable {
            cursor: pointer;
        }
        
        .card.clickable:hover {
            border-color: var(--primary);
        }
        
        /* Trend Modal */
        .trend-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .trend-modal-overlay.active {
            display: flex;
        }
        
        .trend-modal {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .trend-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .trend-modal-header h2 {
            font-size: 1.5rem;
            color: var(--text);
        }
        
        .trend-modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .trend-modal-close:hover {
            background: var(--danger);
        }
        
        .trend-modal-chart {
            height: 300px;
            margin-bottom: 20px;
        }
        
        .trend-modal-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
        }
        
        .trend-stat {
            background: var(--bg);
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        
        .trend-stat-label {
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        
        .trend-stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text);
        }
        
        .card-trend {
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .trend-up { color: var(--success); }
        .trend-down { color: var(--danger); }
        .trend-neutral { color: var(--text-dim); }
        
        .chart-card {
            grid-column: 1 / -1;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
        }
        
        .chart-title {
            font-size: 1.1rem;
            margin-bottom: 16px;
            color: var(--text);
        }
        
        .chart-container {
            position: relative;
            height: 300px;
        }
        
        .chart-container-pmc {
            position: relative;
            height: 350px;
        }
        
        .recommendation-card {
            background: linear-gradient(135deg, var(--card-bg) 0%, #1a2332 100%);
            border: 1px solid var(--primary);
        }
        
        .recovery-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 1.2rem;
            margin-bottom: 12px;
        }
        
        .recovery-high { background: rgba(63, 185, 80, 0.2); color: var(--success); }
        .recovery-moderate { background: rgba(210, 153, 34, 0.2); color: var(--warning); }
        .recovery-easy { background: rgba(210, 153, 34, 0.2); color: var(--warning); }
        .recovery-rest { background: rgba(248, 81, 73, 0.2); color: var(--danger); }
        
        .workout-recommendation {
            margin-top: 16px;
        }
        
        .workout-type {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 8px;
        }
        
        .workout-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }
        
        .workout-detail {
            background: rgba(88, 166, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .workout-detail-label {
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }
        
        .workout-detail-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary);
        }
        
        .alternatives {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        
        .alternatives h4 {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }
        
        .alt-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 0.9rem;
        }
        
        .tips {
            margin-top: 12px;
            padding: 12px;
            background: rgba(88, 166, 255, 0.05);
            border-radius: 8px;
            font-size: 0.85rem;
        }
        
        .tips li {
            margin-left: 16px;
            margin-bottom: 4px;
            color: var(--text-dim);
        }
        
        .weekly-plan {
            grid-column: 1 / -1;
        }
        
        .week-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            margin-top: 16px;
        }
        
        .day-card {
            background: var(--bg);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.85rem;
        }
        
        .day-name {
            color: var(--text-dim);
            font-size: 0.75rem;
            text-transform: uppercase;
            margin-bottom: 6px;
        }
        
        .day-type {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 4px;
        }
        
        .day-duration {
            font-size: 0.8rem;
            color: var(--text-dim);
        }
        
        .day-rest {
            color: var(--danger);
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            color: var(--text-dim);
        }
        
        .error {
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 12px;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
                gap: 6px;
                margin-bottom: 16px;
                padding-bottom: 12px;
            }

            header h1 {
                font-size: 1.1rem;
                line-height: 1.2;
            }

            .subtitle {
                font-size: 0.75rem;
            }

            #last-updated {
                font-size: 0.75rem !important;
            }

            .account-link {
                padding: 6px 8px;
                font-size: 0.85rem;
            }

            header > div:last-child {
                width: 100%;
                justify-content: space-between;
            }

            .date-nav {
                padding: 10px 12px;
                gap: 10px;
            }

            .date-nav-btn {
                padding: 6px 8px;
                min-width: 36px;
                justify-content: center;
            }

            .date-nav-text {
                display: none;
            }
            
            .week-grid {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .grid {
                grid-template-columns: 1fr;
            }
            
            .chart-card {
                padding: 12px;
            }
            
            .workout-header {
                display: none !important;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h1><a href="/" style="text-decoration: none; color: inherit;"><span class="emoji">ü¶û</span> Auroran Health Command Center</a></h1>
                <div class="subtitle">Personal AI Health Dashboard ‚Ä¢ Training Hub</div>
            </div>
            <div style="display: flex; align-items: center; gap: 20px;">
                <div id="last-updated" style="color: var(--text-dim); font-size: 0.85rem;">
                    Loading...
                </div>
                <a href="/account" class="account-link" title="Account Settings">
                    {% if user and user.profile_image %}
                        <img src="{{ user.profile_image }}" alt="Profile" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover;">
                    {% else %}
                        <span style="font-size: 1.2rem;">üë§</span>
                    {% endif %}
                    <span>{{ user.full_name if user else 'Account' }}</span>
                </a>
            </div>
        </header>
        
        <div id="error-container"></div>
        
        <!-- Date Navigation -->
        <div class="date-nav">
            <button class="date-nav-btn" id="date-prev" title="Previous day">
                <span class="arrow-icon">‚óÄ</span><span class="date-nav-text">Previous</span>
            </button>
            <div class="date-nav-current is-today" id="date-current" title="Click to select date or go to today">
                Today
            </div>
            <input type="date" class="date-nav-input" id="date-picker-hidden" autocomplete="off">
            <button class="date-nav-btn" id="date-next" title="Next day" disabled>
                <span class="date-nav-text">Next</span><span class="arrow-icon">‚ñ∂</span>
            </button>
        </div>
        
        <!-- Today's Stats -->
        <div class="grid">
            <div class="card editable-card clickable" data-metric="sleep">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <div class="card-label">üí§ Sleep</div>
                <div class="card-value" id="sleep-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="text" class="card-input" id="sleep-input" placeholder="7h 30m or 7.5">
                <div class="card-trend" id="sleep-trend"></div>
            </div>
            <div class="card editable-card clickable" data-metric="hrv">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <div class="card-label">‚ù§Ô∏è HRV</div>
                <div class="card-value" id="hrv-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="number" step="1" class="card-input" id="hrv-input" placeholder="ms">
                <div class="card-trend" id="hrv-trend"></div>
            </div>
            <div class="card editable-card clickable" data-metric="resting_hr">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <div class="card-label">ü´Ä Resting HR</div>
                <div class="card-value" id="rhr-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="number" step="1" class="card-input" id="rhr-input" placeholder="bpm">
                <div class="card-trend" id="rhr-trend"></div>
            </div>
            <div class="card editable-card clickable" data-metric="steps">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <div class="card-label">üëü Steps</div>
                <div class="card-value" id="steps-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="number" step="100" class="card-input" id="steps-input" placeholder="Steps">
                <div class="card-trend" id="steps-trend"></div>
            </div>
        </div>
        
        <!-- Weight & Calories -->
        <div class="grid">
            <div class="card editable-card clickable" data-metric="weight">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <button class="card-action-btn hide-btn" title="Hide/Show value">üëÅ</button>
                <div class="card-label">‚öñÔ∏è Weight</div>
                <div class="card-value" id="weight-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="number" step="0.1" class="card-input" id="weight-input" placeholder="kg">
                <div class="card-trend" id="weight-trend"></div>
            </div>
            <div class="card editable-card clickable" data-metric="calories">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <div class="card-label">üî• Calories Burned</div>
                <div class="card-value" id="calories-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="number" step="1" class="card-input" id="calories-input" placeholder="kcal">
                <div class="card-trend" id="calories-trend" style="color: var(--text-dim);"></div>
            </div>
        </div>
        
        <!-- PMC / Training Load -->
        <div class="grid">
            <div class="card editable-card clickable" data-metric="ctl" style="border-color: var(--primary);">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <div class="card-label">üí™ CTL (Fitness)</div>
                <div class="card-value" id="ctl-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="number" step="0.1" class="card-input" id="ctl-input" placeholder="CTL">
                <div class="card-trend" style="color: var(--text-dim);">42-day avg</div>
            </div>
            <div class="card editable-card clickable" data-metric="atl" style="border-color: var(--warning);">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <div class="card-label">üî• ATL (Strain)</div>
                <div class="card-value" id="atl-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="number" step="0.1" class="card-input" id="atl-input" placeholder="ATL">
                <div class="card-trend" style="color: var(--text-dim);">7-day avg</div>
            </div>
            <div class="card editable-card clickable" data-metric="tsb" id="tsb-card">
                <div class="card-actions">
                    <button class="card-action-btn edit-btn" title="Edit value">‚úé</button>
                </div>
                <button class="card-action-btn refresh-btn" title="Use automated value">‚Üª</button>
                <div class="card-label">‚öñÔ∏è TSB (Form)</div>
                <div class="card-value" id="tsb-value">--</div>
                <input type="date" class="card-date-picker">
                <input type="number" step="0.1" class="card-input" id="tsb-input" placeholder="TSB">
                <div class="card-trend" id="tsb-status">Loading...</div>
            </div>
        </div>
        
        <!-- PMC 30-day Chart -->
        <div class="chart-card">
            <div class="chart-title">üìä PMC - Performance Management (30-Day)</div>
            <div class="chart-container-pmc">
                <canvas id="pmcChart"></canvas>
            </div>
        </div>

        <!-- Charts -->
        <div class="chart-card">
            <div class="chart-title">üìà 30-Day Health Trends</div>
            <div class="chart-container">
                <canvas id="trendsChart"></canvas>
            </div>
        </div>
        
        <!-- Today's Recommendation -->
        <div class="grid">
            <div class="card recommendation-card" style="grid-column: span 2;">
                <div class="card-label">üéØ Today's Recommendation</div>
                <div id="recovery-badge" class="recovery-badge recovery-high">RECOVERY: --%</div>
                <p id="recommendation-message" style="color: var(--text); margin-bottom: 16px;">
                    Loading your personalized recommendation...
                </p>
                
                <div id="workout-section" class="workout-recommendation">
                    <div class="workout-type" id="workout-type">--</div>
                    <div class="workout-details">
                        <div class="workout-detail">
                            <div class="workout-detail-label">Duration</div>
                            <div class="workout-detail-value" id="workout-duration">--</div>
                        </div>
                        <div class="workout-detail">
                            <div class="workout-detail-label">Zone</div>
                            <div class="workout-detail-value" id="workout-zone">--</div>
                        </div>
                        <div class="workout-detail">
                            <div class="workout-detail-label">Intensity</div>
                            <div class="workout-detail-value" id="workout-intensity">--</div>
                        </div>
                        <div class="workout-detail">
                            <div class="workout-detail-label">Pace</div>
                            <div class="workout-detail-value" id="workout-pace">--</div>
                        </div>
                    </div>
                </div>
                
                <div class="alternatives">
                    <h4>Alternatives</h4>
                    <div id="alternatives-list"></div>
                </div>
                
                <div class="tips">
                    <ul id="tips-list"></ul>
                </div>
            </div>
            
            <!-- Weekly Summary -->
            <div class="card recommendation-card">
                <div class="card-label">üìÖ This Week</div>
                <div id="weekly-status" style="font-size: 1.2rem; font-weight: 600; color: var(--success);">
                    --
                </div>
                <div id="weekly-details" style="margin-top: 12px; font-size: 0.9rem; color: var(--text-dim);">
                    --
                </div>
            </div>
        </div>
        
        <!-- Weekly Plan -->
        <div class="chart-card weekly-plan">
            <div class="chart-title">üóìÔ∏è This Week's Training Plan</div>
            <div class="week-grid" id="week-plan">
                <!-- Populated by JS -->
            </div>
        </div>
        
        <!-- Recent Workouts -->
        <div class="chart-card">
            <div class="chart-title" id="workouts-chart-title">üèÉ Recent Workouts</div>
            <div id="workouts-list">
                <div class="loading">Loading workouts...</div>
            </div>
        </div>
    </div>
    
    <!-- Trend Modal -->
    <div class="trend-modal-overlay" id="trend-modal">
        <div class="trend-modal">
            <div class="trend-modal-header">
                <h2 id="trend-modal-title">Metric Trend</h2>
                <button class="trend-modal-close" id="trend-modal-close">√ó</button>
            </div>
            <div class="trend-modal-chart">
                <canvas id="trend-modal-chart"></canvas>
            </div>
            <div class="trend-modal-stats" id="trend-modal-stats">
                <!-- Stats will be populated dynamically -->
            </div>
        </div>
    </div>
    
    <script>
        // Chart configuration
        let trendsChart = null;
        let pmcChart = null;
        
        // Manual value tracking - must be defined before functions that use them
        const manualValues = {}; // Store manual values locally
        const useManual = {}; // Track which metrics use manual values
        
        // Current viewing date (default: today, local time)
        let currentViewDate = getLocalDateString(new Date());
        
        function getLocalDateString(date) {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }
        
        function getTodayDate() {
            return getLocalDateString(new Date());
        }
        
        function getYesterdayDate() {
            const d = new Date();
            d.setDate(d.getDate() - 1);
            return getLocalDateString(d);
        }
        
        function formatDateDisplay(dateStr) {
            const today = getTodayDate();
            const yesterday = getYesterdayDate();
            
            if (dateStr === today) {
                return 'Today';
            } else if (dateStr === yesterday) {
                return 'Yesterday';
            } else {
                const d = new Date(dateStr + 'T00:00:00');
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            }
        }
        
        function updateDateNavigation() {
            const today = getTodayDate();
            const isToday = currentViewDate === today;
            
            const currentEl = document.getElementById('date-current');
            const nextBtn = document.getElementById('date-next');
            const hiddenPicker = document.getElementById('date-picker-hidden');
            
            currentEl.textContent = formatDateDisplay(currentViewDate);
            currentEl.classList.toggle('is-today', isToday);
            nextBtn.disabled = isToday;
            hiddenPicker.value = currentViewDate;
            hiddenPicker.max = today;
        }
        
        function changeDate(offset) {
            const d = new Date(currentViewDate + 'T00:00:00');
            d.setDate(d.getDate() + offset);
            const newDate = getLocalDateString(d);
            const today = getTodayDate();
            
            // Don't go into the future
            if (newDate > today) return;
            
            currentViewDate = newDate;
            updateDateNavigation();
            
            // Clear manual values for new date and reload
            Object.keys(useManual).forEach(k => useManual[k] = false);
            Object.keys(manualValues).forEach(k => delete manualValues[k]);
            document.querySelectorAll('.manual-value').forEach(el => el.classList.remove('manual-value'));
            
            loadManualValues();
            fetchData();
        }
        
        function initDateNavigation() {
            // Always default to today on initial load
            currentViewDate = getTodayDate();
            const prevBtn = document.getElementById('date-prev');
            const nextBtn = document.getElementById('date-next');
            const currentEl = document.getElementById('date-current');
            const hiddenPicker = document.getElementById('date-picker-hidden');
            
            prevBtn.addEventListener('click', () => changeDate(-1));
            nextBtn.addEventListener('click', () => changeDate(1));
            
            // Click on current date: always open calendar to pick date
            currentEl.addEventListener('click', () => {
                hiddenPicker.showPicker();
            });
            
            // Hidden date picker change
            hiddenPicker.addEventListener('change', (e) => {
                const newDate = e.target.value;
                if (newDate && newDate !== currentViewDate) {
                    currentViewDate = newDate;
                    updateDateNavigation();
                    Object.keys(useManual).forEach(k => useManual[k] = false);
                    Object.keys(manualValues).forEach(k => delete manualValues[k]);
                    document.querySelectorAll('.manual-value').forEach(el => el.classList.remove('manual-value'));
                    loadManualValues();
                    fetchData();
                }
            });
            
            updateDateNavigation();
        }

        function initSwipeNavigation() {
            const swipeTarget = document.querySelector('.container') || document.body;
            let startX = 0;
            let startY = 0;
            let startTime = 0;
            let tracking = false;

            function isInteractiveTarget(target) {
                return !!target.closest('input, textarea, select, button, a, .card-input, .card-date-picker, .trend-modal, canvas');
            }

            const onStart = (clientX, clientY, target) => {
                if (isInteractiveTarget(target)) return;
                startX = clientX;
                startY = clientY;
                startTime = Date.now();
                tracking = true;
            };

            const onEnd = (clientX, clientY) => {
                if (!tracking) return;
                tracking = false;
                const dx = clientX - startX;
                const dy = clientY - startY;
                const dt = Date.now() - startTime;

                const absX = Math.abs(dx);
                const absY = Math.abs(dy);
                const minDistance = 60;
                const maxVertical = 80;
                const maxTime = 700;

                if (absX < minDistance || absY > maxVertical || dt > maxTime) return;

                if (dx < 0) {
                    // Swipe left -> next date (if available)
                    changeDate(1);
                } else {
                    // Swipe right -> previous date
                    changeDate(-1);
                }
            };

            swipeTarget.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 1) return;
                const t = e.touches[0];
                onStart(t.clientX, t.clientY, e.target);
            }, { passive: true });

            swipeTarget.addEventListener('touchmove', (e) => {
                if (!tracking) return;
                if (e.touches.length !== 1) {
                    tracking = false;
                }
            }, { passive: true });

            swipeTarget.addEventListener('touchend', (e) => {
                const t = e.changedTouches[0];
                onEnd(t.clientX, t.clientY);
            }, { passive: true });

            swipeTarget.addEventListener('pointerdown', (e) => {
                if (e.pointerType !== 'touch') return;
                onStart(e.clientX, e.clientY, e.target);
            }, { passive: true });

            swipeTarget.addEventListener('pointerup', (e) => {
                if (e.pointerType !== 'touch') return;
                onEnd(e.clientX, e.clientY);
            }, { passive: true });
        }
        
        // Check if a metric should use manual value
        function shouldUseManual(metric) {
            return useManual[metric] === true && manualValues[metric] !== null && manualValues[metric] !== undefined;
        }
        
        let fetchAbortController = null;
        const FETCH_TIMEOUT_MS = 20000;  // 20s per phase
        async function fetchJson(url, signal) {
            const res = await fetch(url, { signal });
            const text = await res.text();
            let data;
            try {
                data = text ? JSON.parse(text) : {};
            } catch (e) {
                const preview = text.slice(0, 150).replace(/</g, '&lt;');
                throw new Error('Invalid JSON. ' + (res.ok ? '' : 'Status: ' + res.status + '. ') + 'Response: ' + preview);
            }
            if (!res.ok) throw new Error(data.error || 'Request failed (status ' + res.status + ')');
            return data;
        }
        async function fetchWorkoutsOnly(date, signal) {
            // Phase 3 only - retries allowed
            const workoutsRes = await fetch('/api/workouts?before_date=' + date + '&limit=10', { signal });
            if (date !== currentViewDate) return;
            if (workoutsRes.status === 503) {
                const retryAfter = parseInt(workoutsRes.headers.get('Retry-After') || '3', 10);
                setTimeout(() => {
                    if (date === currentViewDate && fetchAbortController) {
                        fetchWorkoutsOnly(date, fetchAbortController.signal);
                    }
                }, retryAfter * 1000);
                return;
            }
            if (!workoutsRes.ok) return;
            const isStale = workoutsRes.headers.get('X-Workouts-Stale') === 'true';
            let workouts = [];
            try {
                const raw = await workoutsRes.json();
                workouts = Array.isArray(raw) ? raw : [];
            } catch (_) { }
            updateWorkouts(workouts);
            document.getElementById('last-updated').textContent = 'Updated: ' + new Date().toLocaleTimeString();
            if (isStale) {
                setTimeout(() => {
                    if (date === currentViewDate && fetchAbortController) {
                        fetchWorkoutsOnly(date, fetchAbortController.signal);
                    }
                }, 2000);
            }
        }

        async function fetchData() {
            if (fetchAbortController) fetchAbortController.abort();
            fetchAbortController = new AbortController();
            const date = currentViewDate;
            const signal = fetchAbortController.signal;
            document.getElementById('error-container').innerHTML = '';
            try {
                // Phase 1: Quick - health, recommendation, calories, weight (fastest)
                let timeoutId = setTimeout(() => fetchAbortController.abort(), FETCH_TIMEOUT_MS);
                const quick = await fetchJson('/api/dashboard/quick?date=' + date, signal);
                clearTimeout(timeoutId);
                if (date !== currentViewDate) return;
                updateHealthCards(quick.health || {});
                updateRecommendation(quick.recommendation || {});
                updateCalories(quick.calories || {});
                updateWeight(quick.weight || {});
                const weekPlan = (quick.recommendation || {}).alternatives ? generateWeekPlan(quick.recommendation) : [];
                updateWeekPlan(weekPlan);
                document.getElementById('last-updated').textContent = 'Updated: ' + new Date().toLocaleTimeString();

                // Phase 2: Charts - history, PMC
                timeoutId = setTimeout(() => fetchAbortController.abort(), FETCH_TIMEOUT_MS);
                const charts = await fetchJson('/api/dashboard/charts?date=' + date + '&days=10', signal);
                clearTimeout(timeoutId);
                if (date !== currentViewDate) return;
                updateChart(charts.history || {});
                updatePMC(charts.pmc || {});
                document.getElementById('last-updated').textContent = 'Updated: ' + new Date().toLocaleTimeString();

                // Phase 3: Workouts (slowest - background + retry)
                fetchWorkoutsOnly(date, signal);
            } catch (error) {
                if (error.name === 'AbortError') return;
                const msg = error.message || String(error);
                const isTimeout = msg.includes('aborted') || msg.includes('Abort');
                console.error('Error fetching data:', error);
                document.getElementById('error-container').innerHTML =
                    '<div class="error">Error loading data: ' + (isTimeout ? 'Request timed out. Try a more recent date.' : msg) + '</div>';
            }
        }
        
        function updateCalories(data) {
            // Ignore stale responses from previous date selections
            if (data.date && data.date !== currentViewDate) {
                return;
            }
            
            const el = document.getElementById('calories-value');
            const trendEl = document.getElementById('calories-trend');
            
            // Always update the date display to match current view
            if (trendEl) {
                trendEl.textContent = currentViewDate;
            }
            
            // Only update value if no manual value is set locally
            if (shouldUseManual('calories')) {
                return; // Keep the manual calorie value
            }
            
            if (el && data.calories !== undefined && data.calories !== null) {
                el.textContent = data.calories.toLocaleString() + ' kcal';
            } else if (el) {
                el.textContent = '--';
            }
        }
        
        function updateWeight(data) {
            // Ignore stale responses from previous date selections
            if (data.date && data.date !== currentViewDate) {
                return;
            }
            
            // Only update if no manual value is set locally
            if (shouldUseManual('weight')) {
                return; // Keep the manual value
            }
            
            const el = document.getElementById('weight-value');
            if (el && data.weight) {
                el.textContent = data.weight.toFixed(1) + ' kg';
                // Mark as manual if from manual source (from API)
                const card = el.closest('.editable-card');
                if (card && data.source === 'manual') {
                    card.classList.add('manual-value');
                    useManual['weight'] = true;
                    manualValues['weight'] = data.weight;
                }
            } else if (el) {
                el.textContent = '--';
            }
        }
        
        function formatHours(hours) {
            if (!hours) return '--';
            const h = Math.floor(hours);
            const m = Math.round((hours - h) * 60);
            return h + 'h ' + m + 'm';
        }

        function updateHealthCards(data) {
            // Only update if no manual value is set
            if (!shouldUseManual('sleep')) {
                document.getElementById('sleep-value').textContent = formatHours(data.sleep_hours);
            }
            if (!shouldUseManual('hrv')) {
                document.getElementById('hrv-value').textContent = data.hrv ? data.hrv + ' ms' : '--';
            }
            if (!shouldUseManual('resting_hr')) {
                document.getElementById('rhr-value').textContent = data.resting_hr ? data.resting_hr + ' bpm' : '--';
            }
            if (!shouldUseManual('steps')) {
                document.getElementById('steps-value').textContent = data.steps ? data.steps.toLocaleString() : '--';
            }
            
            if (data.trend) {
                document.getElementById('sleep-trend').innerHTML = formatTrend(data.trend.sleep, 'sleep');
                document.getElementById('hrv-trend').innerHTML = formatTrend(data.trend.hrv, 'hrv');
                document.getElementById('rhr-trend').innerHTML = formatTrend(data.trend.resting_hr, 'rhr');
            }
        }
        
        function formatTrend(value, type) {
            if (!value) return '';
            let cls = 'trend-neutral';
            if (type === 'hrv' || type === 'sleep') {
                cls = value.includes('+') ? 'trend-up' : (value.includes('-') ? 'trend-down' : 'trend-neutral');
            } else if (type === 'rhr') {
                cls = value.includes('-') ? 'trend-up' : (value.includes('+') ? 'trend-down' : 'trend-neutral');
            }
            return `<span class="${cls}">${value}</span>`;
        }
        
        function updateChart(data) {
            const ctx = document.getElementById('trendsChart').getContext('2d');
            
            if (trendsChart) {
                trendsChart.destroy();
            }
            
            const dates = (data.dates || []).slice(-30);
            const hrv = (data.hrv || []).slice(-30);
            const restingHr = (data.resting_hr || []).slice(-30);
            const sleep = (data.sleep || []).slice(-30);
            const steps = (data.steps || []).slice(-30);

            trendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates.map(d => d.slice(5)),
                    datasets: [
                        {
                            label: 'HRV (ms)',
                            data: hrv,
                            borderColor: '#3fb950',
                            backgroundColor: 'rgba(63, 185, 80, 0.1)',
                            fill: true,
                            tension: 0.4
                        },
                        {
                            label: 'Resting HR (bpm)',
                            data: restingHr,
                            borderColor: '#f85149',
                            backgroundColor: 'rgba(248, 81, 73, 0.1)',
                            fill: true,
                            tension: 0.4,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Sleep (h)',
                            data: sleep,
                            borderColor: '#58a6ff',
                            backgroundColor: 'rgba(88, 166, 255, 0.1)',
                            fill: true,
                            tension: 0.4,
                            yAxisID: 'y2'
                        },
                        {
                            label: 'Steps',
                            data: steps,
                            borderColor: '#a371f7',
                            backgroundColor: 'rgba(163, 113, 247, 0.1)',
                            fill: false,
                            tension: 0.35,
                            yAxisID: 'y3'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: { color: '#c9d1d9' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#8b949e' },
                            grid: { color: '#30363d' }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            ticks: { color: '#3fb950' },
                            grid: { color: '#30363d' },
                            title: { display: true, text: 'HRV (ms)', color: '#3fb950' }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            ticks: { color: '#f85149' },
                            grid: { drawOnChartArea: false },
                            title: { display: true, text: 'HR (bpm)', color: '#f85149' }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            ticks: { color: '#58a6ff', callback: v => v + 'h' },
                            grid: { drawOnChartArea: false },
                            title: { display: true, text: 'Sleep (h)', color: '#58a6ff' }
                        },
                        y3: {
                            type: 'linear',
                            position: 'right',
                            offset: true,
                            ticks: { color: '#a371f7', callback: v => Number(v).toLocaleString() },
                            grid: { drawOnChartArea: false },
                            title: { display: true, text: 'Steps', color: '#a371f7' }
                        }
                    }
                }
            });
        }
        
        function updateRecommendation(data) {
            const badge = document.getElementById('recovery-badge');
            badge.textContent = `RECOVERY: ${data.recovery}%`;
            
            badge.className = 'recovery-badge';
            if (data.recommendation === 'HIGH') {
                badge.classList.add('recovery-high');
            } else if (data.recommendation === 'MODERATE') {
                badge.classList.add('recovery-moderate');
            } else if (data.recommendation === 'EASY') {
                badge.classList.add('recovery-easy');
            } else {
                badge.classList.add('recovery-rest');
            }
            
            document.getElementById('recommendation-message').textContent = data.message;
            
            if (data.workout) {
                document.getElementById('workout-type').textContent = data.workout.type || '--';
                document.getElementById('workout-duration').textContent = data.workout.duration ? data.workout.duration + ' min' : '--';
                document.getElementById('workout-zone').textContent = data.workout.zone || '--';
                document.getElementById('workout-intensity').textContent = data.workout.intensity || '--';
                document.getElementById('workout-pace').textContent = data.workout.pace || '--';
            } else {
                document.getElementById('workout-section').style.display = 'none';
            }
            
            // Alternatives
            const altList = document.getElementById('alternatives-list');
            altList.innerHTML = '';
            if (data.alternatives) {
                data.alternatives.forEach(alt => {
                    altList.innerHTML += `
                        <div class="alt-item">
                            <span>${alt.type}</span>
                            <span style="color: var(--text-dim);">${alt.duration} min</span>
                        </div>
                    `;
                });
            }
            
            // Tips
            const tipsList = document.getElementById('tips-list');
            tipsList.innerHTML = '';
            if (data.tips) {
                data.tips.forEach(tip => {
                    tipsList.innerHTML += `<li>${tip}</li>`;
                });
            }
            
            // Weekly status
            document.getElementById('weekly-status').textContent = data.recommendation;
            document.getElementById('weekly-details').textContent = 
                data.recommendation === 'HIGH' ? 'Great week to push volume!' :
                data.recommendation === 'MODERATE' ? 'Build steadily this week' :
                data.recommendation === 'EASY' ? 'Focus on recovery this week' :
                'Rest is essential';
        }
        
        function updatePMC(data) {
            // CTL (Fitness) - 42 day average - only update if no manual value
            if (!shouldUseManual('ctl')) {
                document.getElementById('ctl-value').textContent = data.ctl || '--';
            }
            
            // ATL (Strain) - 7 day average - only update if no manual value
            if (!shouldUseManual('atl')) {
                document.getElementById('atl-value').textContent = data.atl || '--';
            }
            
            // TSB (Form) = CTL - ATL
            const tsbCard = document.getElementById('tsb-card');
            const tsbValue = document.getElementById('tsb-value');
            const tsbStatus = document.getElementById('tsb-status');
            
            // Only update TSB if no manual value
            if (!shouldUseManual('tsb')) {
                if (data.tsb !== undefined) {
                    const tsb = data.tsb;
                    tsbValue.textContent = tsb > 0 ? '+' + tsb : tsb;
                    
                    // Color code based on TSB
                    if (tsb > 10) {
                        tsbCard.style.borderColor = '#3fb950'; // Green - fresh
                        tsbStatus.innerHTML = '<span style="color: #3fb950;">' + data.status + '</span>';
                    } else if (tsb > -10) {
                        tsbCard.style.borderColor = '#d29922'; // Yellow - balanced
                        tsbStatus.innerHTML = '<span style="color: #d29922;">' + data.status + '</span>';
                    } else {
                        tsbCard.style.borderColor = '#f85149'; // Red - fatigued
                        tsbStatus.innerHTML = '<span style="color: #f85149;">' + data.status + '</span>';
                    }
                } else {
                    tsbValue.textContent = '--';
                    tsbStatus.textContent = 'No data';
                }
            }

            updatePMCChart(data.chart || {});
        }

        function updatePMCChart(chart) {
            const canvas = document.getElementById('pmcChart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            if (pmcChart) {
                pmcChart.destroy();
            }

            const dates = (chart.dates || []).slice(-30);
            const ctl = (chart.ctl || []).slice(-30);
            const atl = (chart.atl || []).slice(-30);
            const tsb = (chart.tsb || []).slice(-30);

            // Calculate appropriate Y-axis range based on data
            const allCtlAtl = [...ctl, ...atl].filter(v => v != null);
            const allTsb = tsb.filter(v => v != null);
            
            // For CTL/ATL: add padding to make 10-point changes visible
            const ctlAtlMin = Math.min(...allCtlAtl);
            const ctlAtlMax = Math.max(...allCtlAtl);
            const ctlAtlRange = ctlAtlMax - ctlAtlMin;
            const ctlAtlPadding = Math.max(10, ctlAtlRange * 0.15);
            const yMin = Math.max(0, Math.floor((ctlAtlMin - ctlAtlPadding) / 10) * 10);
            const yMax = Math.ceil((ctlAtlMax + ctlAtlPadding) / 10) * 10;
            
            // For TSB: separate scale since it can go negative
            const tsbMin = Math.min(...allTsb);
            const tsbMax = Math.max(...allTsb);
            const tsbPadding = Math.max(5, (tsbMax - tsbMin) * 0.15);
            const y2Min = Math.floor((tsbMin - tsbPadding) / 10) * 10;
            const y2Max = Math.ceil((tsbMax + tsbPadding) / 10) * 10;

            pmcChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates.map(d => d.slice(5)),
                    datasets: [
                        {
                            label: 'CTL (Fitness)',
                            data: ctl,
                            borderColor: '#58a6ff',
                            backgroundColor: 'rgba(88, 166, 255, 0.1)',
                            borderWidth: 2,
                            tension: 0.35,
                            fill: false,
                            yAxisID: 'y'
                        },
                        {
                            label: 'ATL (Strain)',
                            data: atl,
                            borderColor: '#d29922',
                            backgroundColor: 'rgba(210, 153, 34, 0.1)',
                            borderWidth: 2,
                            tension: 0.35,
                            fill: false,
                            yAxisID: 'y'
                        },
                        {
                            label: 'TSB (Form)',
                            data: tsb,
                            borderColor: '#3fb950',
                            backgroundColor: 'rgba(63, 185, 80, 0.1)',
                            borderWidth: 2,
                            tension: 0.35,
                            fill: false,
                            yAxisID: 'y2'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: { color: '#c9d1d9' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#8b949e' },
                            grid: { color: '#30363d' }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            min: yMin,
                            max: yMax,
                            ticks: { 
                                color: '#c9d1d9',
                                stepSize: 10
                            },
                            grid: { color: '#30363d' },
                            title: { display: true, text: 'CTL / ATL', color: '#8b949e' }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            min: y2Min,
                            max: y2Max,
                            ticks: { 
                                color: '#3fb950',
                                stepSize: 10
                            },
                            grid: { drawOnChartArea: false },
                            title: { display: true, text: 'TSB (Form)', color: '#3fb950' }
                        }
                    }
                }
            });
        }
        
        function generateWeekPlan(recommendation) {
            const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            const plan = [];
            
            // Generate based on recommendation
            if (recommendation.recommendation === 'HIGH') {
                plan.push({day: 'Mon', type: 'Intervals', duration: 45});
                plan.push({day: 'Tue', type: 'Easy Run', duration: 35});
                plan.push({day: 'Wed', type: 'Strength', duration: 45});
                plan.push({day: 'Thu', type: 'Tempo', duration: 40});
                plan.push({day: 'Fri', type: 'Rest', duration: 0});
                plan.push({day: 'Sat', type: 'Long Run', duration: 75});
                plan.push({day: 'Sun', type: 'Rest', duration: 0});
            } else if (recommendation.recommendation === 'MODERATE') {
                plan.push({day: 'Mon', type: 'Easy Run', duration: 40});
                plan.push({day: 'Tue', type: 'Strength', duration: 45});
                plan.push({day: 'Wed', type: 'Rest', duration: 0});
                plan.push({day: 'Thu', type: 'Tempo', duration: 35});
                plan.push({day: 'Fri', type: 'Rest', duration: 0});
                plan.push({day: 'Sat', type: 'Long Run', duration: 50});
                plan.push({day: 'Sun', type: 'Rest', duration: 0});
            } else {
                plan.push({day: 'Mon', type: 'Rest', duration: 0});
                plan.push({day: 'Tue', type: 'Easy', duration: 25});
                plan.push({day: 'Wed', type: 'Rest', duration: 0});
                plan.push({day: 'Thu', type: 'Easy', duration: 25});
                plan.push({day: 'Fri', type: 'Rest', duration: 0});
                plan.push({day: 'Sat', type: 'Walk', duration: 30});
                plan.push({day: 'Sun', type: 'Rest', duration: 0});
            }
            
            return plan;
        }
        
        function updateWeekPlan(plan) {
            const container = document.getElementById('week-plan');
            container.innerHTML = '';
            
            plan.forEach(day => {
                const isRest = day.type === 'Rest';
                container.innerHTML += `
                    <div class="day-card">
                        <div class="day-name">${day.day}</div>
                        <div class="day-type ${isRest ? 'day-rest' : ''}">${day.type}</div>
                        <div class="day-duration">${isRest ? 'Rest' : day.duration + ' min'}</div>
                    </div>
                `;
            });
        }
        
        function formatWorkoutsHeaderDate(dateStr) {
            const d = new Date(dateStr + 'T00:00:00');
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function updateWorkouts(workouts) {
            const container = document.getElementById('workouts-list');
            const titleEl = document.getElementById('workouts-chart-title');
            if (titleEl) {
                titleEl.textContent = 'üèÉ Recent Workouts (through ' + formatWorkoutsHeaderDate(currentViewDate) + ')';
            }
            
            if (!workouts || workouts.length === 0) {
                container.innerHTML = '<div class="loading">No workouts yet. Add your first workout!</div>';
                return;
            }
            
            // Header row - right align to match data
            let html = `<div class="workout-header" style="display: none; padding: 8px 12px; 
                        border-bottom: 2px solid var(--border); color: var(--text-dim); font-size: 11px; font-weight: 600;">
                        <span>WORKOUT</span>
                        <span>min ‚Üëm ‚ö°EFFORT bpm</span>
                    </div>`;
            
            workouts.slice(0, 10).forEach(w => {
                const isSwimming = w.type && w.type.toLowerCase().includes('swim');
                const distance = w.distance ? (isSwimming ? Math.round(w.distance) + 'm' : (w.distance / 1000).toFixed(1) + 'km') : '';
                const elevation = w.elevation_gain ? Math.round(w.elevation_gain) + 'm' : '';
                const effort = w.suffer_score ? Math.round(w.suffer_score) : '';
                const hr = w.avg_hr ? Math.round(w.avg_hr) : '';
                const cal = w.calories ? Math.round(w.calories) : '';
                const time = w.time ? w.time : (w.start_time ? w.start_time : '');
                const name = w.name ? w.name : w.type;
                
                const dur = (w.duration || w.duration_minutes || '--') + ' min';
                const elev = elevation ? '‚Üë' + elevation : '';
                const eff = effort ? '‚ö°' + effort : '';
                const heart = hr ? hr + ' bpm' : '';
                const calories = cal ? cal + ' kcal' : '';
                
                // Mobile-friendly card layout
                const stravaUrl = w.strava_id ? `https://www.strava.com/activities/${w.strava_id}` : '';
                const workoutLink = stravaUrl ? `<a href="${stravaUrl}" target="_blank" rel="noopener" style="color: inherit; text-decoration: none;">${name}</a>` : name;
                
                html += `
                    <div style="padding: 12px; border-bottom: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: baseline; flex-wrap: wrap; gap: 4px;">
                            <div style="flex: 1; min-width: 140px;">
                                <span style="font-weight: 600;">${workoutLink}</span>
                                <span style="color: var(--text-dim); margin-left: 6px;">${w.date}</span>
                                ${time ? `<span style="color: var(--text-dim); margin-left: 4px;">${time}</span>` : ''}
                            </div>
                            ${distance ? `<span style="color: var(--accent); font-weight: 600;">${distance}</span>` : ''}
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 12px; color: var(--text-dim); flex-wrap: wrap; gap: 4px;">
                            <span>${dur}</span>
                            <span>${elev}</span>
                            <span style="color: #f59e0b; font-weight: 600;">${eff}</span>
                            <span>${heart}</span>
                            ${calories ? `<span style="color: #ef4444;">üî•${calories}</span>` : ''}
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // Manual value editing functionality
        function getDefaultDate(card) {
            // Returns default date for a card (current view date, or day before for calories)
            const viewDate = new Date(currentViewDate + 'T00:00:00');
            if (card.dataset.defaultDate === 'yesterday') {
                viewDate.setDate(viewDate.getDate() - 1);
            }
            return getLocalDateString(viewDate);
        }
        
        function setAutoPreviewState(card, editBtn, enabled) {
            if (enabled) {
                card.dataset.autoPreview = 'true';
                editBtn.textContent = '‚úì';
                editBtn.title = 'Use automated value';
                editBtn.classList.add('active');
            } else {
                delete card.dataset.autoPreview;
                editBtn.textContent = '‚úé';
                editBtn.title = 'Edit value';
                editBtn.classList.remove('active');
            }
        }
        
        function initEditableCards() {
            document.querySelectorAll('.editable-card').forEach(card => {
                const metric = card.dataset.metric;
                const editBtn = card.querySelector('.edit-btn');
                const refreshBtn = card.querySelector('.refresh-btn');
                const valueEl = card.querySelector('.card-value');
                const inputEl = card.querySelector('.card-input');
                const dateEl = card.querySelector('.card-date-picker');
                
                if (!editBtn || !inputEl) return;
                
                // Edit button click
                editBtn.addEventListener('click', () => {
                    const isAutoPreview = card.dataset.autoPreview === 'true';
                    const isEditing = inputEl.classList.contains('editing');
                    
                    if (isAutoPreview && !isEditing) {
                        // Commit to automated value (clear manual override)
                        clearManualValue(metric);
                        useManual[metric] = false;
                        card.classList.remove('manual-value');
                        setAutoPreviewState(card, editBtn, false);
                        fetchData();
                        return;
                    }
                    
                    if (isEditing) {
                        // Save the value
                        const newValue = parseFloat(inputEl.value);
                        const selectedDate = dateEl ? dateEl.value : getDefaultDate(card);
                        console.log('Saving:', metric, '=', newValue, 'on date:', selectedDate);
                        if (!isNaN(newValue)) {
                            saveManualValue(metric, newValue, selectedDate);
                            useManual[metric] = true;
                            card.classList.add('manual-value');
                            updateDisplayValue(metric, newValue);
                        } else {
                            alert('Invalid value: ' + inputEl.value);
                        }
                        inputEl.classList.remove('editing');
                        valueEl.classList.remove('editing');
                        if (dateEl) dateEl.classList.remove('editing');
                        setAutoPreviewState(card, editBtn, false);
                    } else {
                        // Start editing - set default date
                        setAutoPreviewState(card, editBtn, false);
                        if (dateEl) {
                            dateEl.value = getDefaultDate(card);
                            dateEl.classList.add('editing');
                        }
                        const currentValue = extractNumericValue(valueEl.textContent);
                        inputEl.value = currentValue || '';
                        inputEl.classList.add('editing');
                        valueEl.classList.add('editing');
                        inputEl.focus();
                        editBtn.textContent = '‚úì';
                        editBtn.title = 'Save value';
                        editBtn.classList.add('active');
                    }
                });
                
                // Handle Enter key in input
                inputEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        editBtn.click();
                    } else if (e.key === 'Escape') {
                        inputEl.classList.remove('editing');
                        valueEl.classList.remove('editing');
                        if (dateEl) dateEl.classList.remove('editing');
                        editBtn.textContent = '‚úé';
                        editBtn.title = 'Edit value';
                        editBtn.classList.remove('active');
                    }
                });
                
                // Refresh button click - use automated value
                refreshBtn.addEventListener('click', () => {
                    // Preview automated value without deleting manual override
                    useManual[metric] = false;
                    card.classList.remove('manual-value');
                    setAutoPreviewState(card, editBtn, true);
                    fetchData(); // Refresh to get automated value
                });
            });
        }
        
        function parseSleepValue(text) {
            if (!text) return null;
            // Handle H:MM format without h (e.g., "4:41", "7:30")
            const colonMatch = text.match(/^(\d{1,2}):(\d{2})$/);
            if (colonMatch) {
                return parseInt(colonMatch[1]) + parseInt(colonMatch[2]) / 60;
            }
            // Handle hh:mm format with h (e.g., "7h 30m", "7:30m", "7 h 30 m")
            const hmMatch = text.match(/(\d+)\s*h\s*[.:]\s*(\d+)\s*m?/);
            if (hmMatch) {
                return parseInt(hmMatch[1]) + parseInt(hmMatch[2]) / 60;
            }
            // Handle just hours with h (e.g., "7.5h" or "7h")
            const hMatch = text.match(/(\d+\.?\d*)\s*h?/);
            return hMatch ? parseFloat(hMatch[1]) : null;
        }

        function formatSleepValue(hours) {
            if (!hours) return '--';
            const h = Math.floor(hours);
            const m = Math.round((hours - h) * 60);
            return h + 'h ' + m + 'm';
        }

        function extractNumericValue(text) {
            if (!text) return null;
            // For sleep, try to parse hh:mm format
            if (text.includes('h') || text.includes(':')) {
                return parseSleepValue(text);
            }
            const match = text.match(/[\d.]+/);
            return match ? parseFloat(match[0]) : null;
        }

        function updateDisplayValue(metric, value) {
            const formatters = {
                sleep: v => formatSleepValue(v),
                hrv: v => Math.round(v) + ' ms',
                resting_hr: v => Math.round(v) + ' bpm',
                steps: v => Math.round(v).toLocaleString(),
                weight: v => v.toFixed(1) + ' kg',
                calories: v => Math.round(v).toLocaleString() + ' kcal',
                ctl: v => v.toFixed(1),
                atl: v => v.toFixed(1),
                tsb: v => (v >= 0 ? '+' : '') + v.toFixed(1)
            };
            
            const elementIds = {
                sleep: 'sleep-value',
                hrv: 'hrv-value',
                resting_hr: 'rhr-value',
                steps: 'steps-value',
                weight: 'weight-value',
                calories: 'calories-value',
                ctl: 'ctl-value',
                atl: 'atl-value',
                tsb: 'tsb-value'
            };
            
            const el = document.getElementById(elementIds[metric]);
            if (el && formatters[metric]) {
                el.textContent = formatters[metric](value);
            }
        }
        
        async function saveManualValue(metric, value, date = null) {
            try {
                const saveDate = date || getLocalDateString(new Date());
                console.log('API call: saving', metric, '=', value, 'for date', saveDate);
                const response = await fetch('/api/manual-values', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        metric: metric,
                        value: value,
                        date: saveDate
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    alert('Failed to save ' + metric + ': ' + (err.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error saving ' + metric + ': ' + error.message);
            }
        }
        
        async function clearManualValue(metric) {
            try {
                const response = await fetch('/api/manual-values', {
                    method: 'DELETE',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        metric: metric,
                        date: currentViewDate
                    })
                });
                
                if (!response.ok) {
                    console.error('Failed to clear manual value');
                }
            } catch (error) {
                console.error('Error clearing manual value:', error);
            }
        }
        
        async function loadManualValues() {
            try {
                const response = await fetch('/api/manual-values?date=' + currentViewDate);
                if (response.ok) {
                    const data = await response.json();
                    Object.entries(data).forEach(([metric, value]) => {
                        if (value !== null && value !== undefined) {
                            manualValues[metric] = value;
                            useManual[metric] = true;
                            const card = document.querySelector(`.editable-card[data-metric="${metric}"]`);
                            if (card) {
                                card.classList.add('manual-value');
                                const editBtn = card.querySelector('.edit-btn');
                                if (editBtn) {
                                    setAutoPreviewState(card, editBtn, false);
                                }
                            }
                            updateDisplayValue(metric, value);
                        }
                    });
                }
            } catch (error) {
                console.error('Error loading manual values:', error);
            }
        }
        
        // Initialize editable cards
        initEditableCards();
        
        // Initialize date navigation
        initDateNavigation();
        initSwipeNavigation();
        
        // Trend modal functionality
        let trendModalChart = null;
        const metricConfig = {
            sleep: { label: 'Sleep', unit: 'h', color: '#58a6ff', icon: 'üí§', field: 'sleep' },
            hrv: { label: 'HRV', unit: 'ms', color: '#3fb950', icon: '‚ù§Ô∏è', field: 'hrv' },
            resting_hr: { label: 'Resting HR', unit: 'bpm', color: '#f85149', icon: 'ü´Ä', field: 'resting_hr' },
            steps: { label: 'Steps', unit: '', color: '#a371f7', icon: 'üëü', field: 'steps' },
            weight: { label: 'Weight', unit: 'kg', color: '#f0883e', icon: '‚öñÔ∏è', field: 'weight' },
            calories: { label: 'Calories Burned', unit: 'kcal', color: '#ef4444', icon: 'üî•', field: 'calories' },
            ctl: { label: 'CTL (Fitness)', unit: '', color: '#58a6ff', icon: 'üí™', field: 'ctl' },
            atl: { label: 'ATL (Strain)', unit: '', color: '#d29922', icon: 'üî•', field: 'atl' },
            tsb: { label: 'TSB (Form)', unit: '', color: '#3fb950', icon: '‚öñÔ∏è', field: 'tsb' }
        };
        
        async function openTrendModal(metric) {
            const config = metricConfig[metric];
            if (!config) return;
            
            const modal = document.getElementById('trend-modal');
            const title = document.getElementById('trend-modal-title');
            const statsContainer = document.getElementById('trend-modal-stats');
            
            title.textContent = `${config.icon} ${config.label} - 30 Day Trend`;
            modal.classList.add('active');
            
            // Fetch trend data
            try {
                let data = [];
                let dates = [];
                
                if (['ctl', 'atl', 'tsb'].includes(metric)) {
                    // PMC data (use currentViewDate)
                    const response = await fetch('/api/pmc?days=30&end_date=' + currentViewDate);
                    const pmcData = await response.json();
                    if (pmcData.chart) {
                        dates = pmcData.chart.dates || [];
                        data = pmcData.chart[metric] || [];
                    }
                } else {
                    // Health history data (use currentViewDate so trend matches view)
                    const response = await fetch('/api/health/history?days=30&end_date=' + currentViewDate);
                    const historyData = await response.json();
                    dates = historyData.dates || [];
                    data = historyData[config.field] || [];
                }
                
                // Calculate stats
                const validData = data.filter(v => v !== null && v !== undefined);
                const avg = validData.length > 0 ? validData.reduce((a, b) => a + b, 0) / validData.length : 0;
                const min = validData.length > 0 ? Math.min(...validData) : 0;
                const max = validData.length > 0 ? Math.max(...validData) : 0;
                const latest = validData.length > 0 ? validData[validData.length - 1] : 0;
                
                // Update stats
                statsContainer.innerHTML = `
                    <div class="trend-stat">
                        <div class="trend-stat-label">Current</div>
                        <div class="trend-stat-value">${formatValue(latest, metric)}</div>
                    </div>
                    <div class="trend-stat">
                        <div class="trend-stat-label">Average</div>
                        <div class="trend-stat-value">${formatValue(avg, metric)}</div>
                    </div>
                    <div class="trend-stat">
                        <div class="trend-stat-label">Min</div>
                        <div class="trend-stat-value">${formatValue(min, metric)}</div>
                    </div>
                    <div class="trend-stat">
                        <div class="trend-stat-label">Max</div>
                        <div class="trend-stat-value">${formatValue(max, metric)}</div>
                    </div>
                `;
                
                // Create chart
                const ctx = document.getElementById('trend-modal-chart').getContext('2d');
                if (trendModalChart) {
                    trendModalChart.destroy();
                }
                
                trendModalChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates.map(d => d ? d.slice(5) : ''),
                        datasets: [{
                            label: config.label,
                            data: data,
                            borderColor: config.color,
                            backgroundColor: config.color + '20',
                            fill: true,
                            tension: 0.4,
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => `${config.label}: ${formatValue(ctx.raw, metric)}`
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#8b949e' },
                                grid: { color: '#30363d' }
                            },
                            y: {
                                ticks: { 
                                    color: config.color,
                                    callback: (v) => formatValue(v, metric)
                                },
                                grid: { color: '#30363d' }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading trend data:', error);
                statsContainer.innerHTML = '<div class="trend-stat"><div class="trend-stat-value">Error loading data</div></div>';
            }
        }
        
        function formatValue(value, metric) {
            if (value === null || value === undefined) return '--';
            const config = metricConfig[metric];
            if (metric === 'steps') {
                return Math.round(value).toLocaleString();
            } else if (metric === 'tsb') {
                return (value >= 0 ? '+' : '') + value.toFixed(1);
            } else if (['ctl', 'atl', 'hrv', 'resting_hr'].includes(metric)) {
                return Math.round(value) + (config.unit ? ' ' + config.unit : '');
            } else {
                return value.toFixed(1) + (config.unit ? ' ' + config.unit : '');
            }
        }
        
        function closeTrendModal() {
            const modal = document.getElementById('trend-modal');
            modal.classList.remove('active');
            if (trendModalChart) {
                trendModalChart.destroy();
                trendModalChart = null;
            }
        }
        
        // Close modal on button click or overlay click
        document.getElementById('trend-modal-close').addEventListener('click', closeTrendModal);
        document.getElementById('trend-modal').addEventListener('click', (e) => {
            if (e.target.id === 'trend-modal') {
                closeTrendModal();
            }
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeTrendModal();
            }
        });
        
        // Add click handlers to clickable cards
        document.querySelectorAll('.card.clickable').forEach(card => {
            card.addEventListener('click', (e) => {
                // Don't open modal if clicking on buttons, inputs, or date picker
                if (e.target.closest('.card-action-btn') || 
                    e.target.closest('.card-input') || 
                    e.target.closest('.card-date-picker')) {
                    return;
                }
                // Don't open modal if card is in edit mode
                const inputEl = card.querySelector('.card-input');
                if (inputEl && inputEl.classList.contains('editing')) {
                    return;
                }
                const metric = card.dataset.metric;
                if (metric) {
                    openTrendModal(metric);
                }
            });
        });
        
        // Hide/show functionality for weight card
        const hiddenCards = JSON.parse(localStorage.getItem('hiddenCards') || '{}');
        
        function initHideButtons() {
            document.querySelectorAll('.hide-btn').forEach(btn => {
                const card = btn.closest('.card');
                const metric = card.dataset.metric;
                
                // Apply saved hidden state
                if (hiddenCards[metric]) {
                    card.classList.add('hidden-card');
                    btn.textContent = 'üëÅ‚Äçüó®';
                    btn.title = 'Show value';
                }
                
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isHidden = card.classList.toggle('hidden-card');
                    hiddenCards[metric] = isHidden;
                    localStorage.setItem('hiddenCards', JSON.stringify(hiddenCards));
                    
                    if (isHidden) {
                        btn.textContent = 'üëÅ‚Äçüó®';
                        btn.title = 'Show value';
                    } else {
                        btn.textContent = 'üëÅ';
                        btn.title = 'Hide value';
                    }
                });
            });
        }
        
        initHideButtons();
        
        // Initial load - load manual values FIRST, then fetch automated data
        async function initialLoad() {
            // Force today as default view date on page load
            currentViewDate = getTodayDate();
            updateDateNavigation();
            await loadManualValues();  // Wait for manual values to load first
            await fetchData();         // Then fetch automated data (which respects manual overrides)
        }
        initialLoad();
        
        // Refresh every 5 minutes
        setInterval(fetchData, 300000);
    </script>
</body>
</html>
